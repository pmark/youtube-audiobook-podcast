// Generated by CoffeeScript 1.6.3
module.exports.combiner = function() {
  var async, http, parser, path, rss, url, urls, _;
  async = require('async');
  _ = require('underscore');
  url = require('url');
  path = require('path');
  http = require('http');
  parser = require('parse-rss');
  rss = (require('./rss')).rss();
  urls = [];
  return {
    deleteAll: function() {
      urls = new Array();
      return rss.init();
    },
    add: function(req, callback) {
      if (_.isString(req)) {
        urls.push(req);
        if (callback != null) {
          return callback(urls);
        }
      } else if (_.isArray(req)) {
        return async.forEach(req, function(val, cb) {
          urls.push(val);
          return cb();
        }, function() {
          if (callback != null) {
            return callback(_.uniq(urls));
          }
        });
      }
    },
    del: function(req, callback) {
      if (_.isString(req)) {
        urls = _.reject(urls, function(iterator_url) {
          return iterator_url === req;
        });
        if (callback != null) {
          return callback(urls);
        }
      } else if (_.isArray(req)) {
        return async.forEach(req, function(val, cb) {
          urls = _.reject(urls, function(iterator_url) {
            return iterator_url === val;
          });
          return cb();
        }, function() {
          if (callback != null) {
            return callback(urls);
          }
        });
      }
    },
    combine: function(callback) {
      rss.init();
      return async.forEach(urls, function(url, cb) {
        return parser(url, function(err, articles) {
          if (articles) {            
            articles.clean();
            rss.articles = rss.articles.concat(articles);
          }
          return cb();
        });
      }, function() {
        rss.articles = _.sortBy(_.uniq(rss.articles), function(article) {
          if (!article) {
            return 0;
          }
          return article.pubDate.getTime();
        });
        rss.articles.reverse();
        if (callback != null) {
          return callback(rss);
        }
      });
    },
    crawl: function(callback) {
      return this.combine(callback);
    },
    geturls: function() {
      return urls;
    },
    rss: function() {
      return rss;
    }
  };
};

Array.prototype.clean = function(deleteValue) {
  for (var i = 0; i < this.length; i++) {
    if (this[i] == deleteValue) {         
      this.splice(i, 1);
      i--;
    }
  }
  return this;
};
